  복잡도 계산 공식 (project.py:1140-1146)

  complexity = (
      lines * 1 +           # 라인당 1점
      fields * 2 +          # 필드당 2점
      methods * 5 +         # 메서드당 5점
      inner_classes * 10 +  # Inner class당 10점
      annotations * 1       # 어노테이션당 1점
  )

  측정 항목

  1. 라인 수 (1점/라인)
    - 전체 줄 바꿈(\n) 개수
  2. 필드 수 (2점/필드)
    - private , public , protected  키워드 개수
  3. 메서드 수 (5점/메서드)
    - private , public , protected  키워드 개수 (필드와 동일)
  4. Inner Class 수 (10점/클래스)
    - static class , class  키워드 개수
  5. 어노테이션 수 (1점/어노테이션)
    - @ 심볼 개수

  임계값 50000의 의미

  통과하는 예시 (정상 범위)

  | 케이스            | 라인   | 필드  | 메서드 | Inner Class | 어노테이션 | 총점    |
  |----------------|------|-----|-----|-------------|-------|-------|
  | 일반 클래스         | 1000 | 50  | 30  | 2           | 50    | 1,370 |
  | 대형 Service     | 3000 | 100 | 200 | 5           | 300   | 4,400 |
  | 대규모 DTO        | 500  | 500 | 10  | 0           | 100   | 1,700 |
  | 복잡한 Controller | 2000 | 200 | 100 | 10          | 500   | 3,600 |

  제외되는 예시 (극단적 케이스)

  | 케이스            | 라인    | 필드   | 메서드  | Inner Class | 어노테이션 | 총점       |
  |----------------|-------|------|------|-------------|-------|----------|
  | 자동생성 DTO       | 2000  | 1000 | 1000 | 0           | 1000  | 9,000 ⚠️ |
  | 거대한 파일         | 20000 | 1000 | 500  | 10          | 500   | 25,100 ❌ |
  | Inner Class 폭발 | 5000  | 100  | 100  | 5000        | 200   | 55,900 ❌ |

  권장 임계값

  - 기본값: 50,000 - 대부분의 정상 파일 통과, 극단적 케이스만 제외
  - 엄격: 20,000 - 대형 파일도 제외 (더 빠른 분석)
  - 관대: 100,000 - 거의 모든 파일 포함 (완전성 우선)

  실제 적용 예시

  v0.6 성능 개선 효과:
  - 739개 파일 중 1개 파일이 42분 소요
  - 복잡도 기반 정렬로 해당 파일을 먼저 처리
  - 워커 유휴 시간 감소 → 전체 시간 89% 단축

  현재 설정 (50000):
  - 필드 500개 이상의 자동생성 코드 제외
  - 정상적인 비즈니스 로직은 모두 포함
  - 성능과 완전성의 균형

  필요에 따라 .env의 JAVA_COMPLEXITY_THRESHOLD 값을 조정하시면 됩니다!

  ---
  # 인지 복합도(Cognitive Complexity)
  ## 메서드 복잡도: 코드의 가독성/유지보수성을 판단 (즉각적인 리팩토링 대상 식별)
  ## 클래스 복잡도: **설계의 적절성(응집도)**을 판단 (설계 구조 검토 대상 식별)아래에 SonarQube를 기준으로 한 업계 표준 가이드를 제시해 드립니다.
  1. 🎯 메서드(Method) 대상 기준 (가장 중요)인지 복잡도를 만든 SonarSource(SonarQube 개발사)에서 권장하는 **기본 임계값(Threshold)**입니다. 
  이 기준은 코드의 가독성 및 유지보수성과 직결됩니다.
  - 기준값: 15
  |인지 복잡도|상태|조치 (Action)|
  |-----------|----|-------------|
  |0 ~ 10|양호 (Good)|이상적이며 유지보수하기 쉬운 코드입니다.|
  |11 ~ 15|관리 필요 (Moderate)|코드가 복잡해지기 시작하는 단계입니다. 리팩토링을 고려해 볼 수 있습니다.|
  |16 이상|🚨 리팩토링 필요 (High)|SonarQube에서 기본적으로 Code Smell로 감지합니다.코드를 이해하고 테스트하기 매우 어려우며, 버그 발생 가능성이 높습니다.|
  ▶︎ 리팩토링 방안: 기준값(15)을 초과하는 메서드는 "너무 많은 일을 하고 있다"는 명확한 신호입니다.
  - 메서드 추출 (Extract Method): 메서드 내부의 논리 덩어리를 더 작은 private 메서드들로 분리하여 중첩을 줄이고 가독성을 높여야 합니다.
  
  2. 📊 클래스(Class) / 파일(File) 대상 기준 (설계 진단용)클래스(파일) 레벨의 복잡도는 메서드처럼 "15"와 같은 단일한 절대적 기준값(Hard threshold)은 없습니다.
  이유는 클래스의 총 복잡도는 **'모든 메서드 복잡도의 합(SUM)'**이기 때문입니다. 
  예를 들어, 50개의 간단한 Getter/Setter (각각 복잡도 0 또는 1)만 가진 DTO 클래스는 총합이 50이 넘을 수 있지만, 이는 전혀 복잡한 클래스가 아닙니다.
  대신, 이 값은 **클래스 설계의 '냄새(Smell)'를 맡기 위한 경험적 기준(Heuristic)**으로 사용됩니다.
  기준값: (경험적) 
  - 약 100~150
  |클래스 총 복잡도|상태|진단 (Diagnosis)|
  |----------------|----|----------------|
  |0 ~ 50|양호 (Good)|클래스의 책임이 명확하고 응집도가 높을 가능성이 큽니다. (이상적)|
  |51 ~ 100|일반적 (Common)|일반적인 서비스, 컨트롤러, 매니저 클래스에서 흔히 보이는 수치입니다.|
  |101 ~ 200|⚠️ 과중 의심 (Suspicion)클래스가 너무 많은 책임을 가지고 있을 가능성이 높습니다.단일 책임 원칙(SRP) 위반을 의심해야 합니다.|
  |200 이상|🚨 설계 결함 (High Risk)|**'갓 클래스(God Class)'**일 확률이 매우 높습니다.이 클래스는 유지보수의 암덩어리가 될 수 있습니다.|