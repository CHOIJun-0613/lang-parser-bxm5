# CSA GUI 구현 방안 (2025-11-07)

## 1. 추진 배경과 목표
- CSA는 현재 CLI 기반으로 제공되어 학습 곡선이 높고 반복 명령 관리가 어렵다.
- GUI는 프로젝트/명령/환경 구성을 시각적으로 관리해 분석 속도를 높이고 신규 사용자 온보딩을 단축한다.
- 목표: (1) 분석 흐름 템플릿화, (2) 결과 시각화의 즉시 접근성 확보, (3) Neo4j/출력물 상태 모니터링 일원화.

## 2. 사용자 시나리오 요약
| 페르소나 | 주요 과업 | 필요 기능 |
| --- | --- | --- |
| 품질/아키텍트 리더 | 다수 서비스의 정적 분석 상태 점검, 리포트 수집 | 프로젝트 대시보드, 예약 실행, 결과 다운로드 |
| 백엔드 개발자 | 특정 모듈 영향도 확인, 시퀀스 다이어그램 생성 | 클래스/메서드 탐색, 시각화 미리보기, 빠른 실행 파라미터 편집 |
| 데이터 거버넌스 담당 | 테이블 영향도와 CRUD 매트릭스 확인 | 테이블 검색, 분석 결과 히트맵, Neo4j 연결 상태 모니터링 |

## 3. 핵심 요구사항
### 기능 요구
- 프로젝트 템플릿 기반으로 `.env`와 CLI 옵션을 GUI에서 생성/관리
- Analyze/AI-Enrich/Sequence/Impact 등 핵심 명령을 파라미터와 함께 실행, 진행률/로그 스트리밍
- 분석 결과(그래프 통계, CRUD 매트릭스, 다이어그램)를 즉시 뷰어/다운로드
- Neo4j 연결 상태 및 최근 작업 이력 모듈
- 예약 실행(로컬 스케줄러) 및 결과 아카이브 관리

### 비기능 요구
- Windows/Linux/macOS 호환
- CSA Python 버전과 동일한 가상환경 재사용
- 설치 용량 150MB 이하, 배포 자동 업데이트
- 로그/설정 파일은 사용자 홈 경로에 저장, 기업망 오프라인 환경 고려
- 다국어(ko/en) 확장 가능 구조

## 4. 기술 선정 기준
- Python 기반 분석 엔진과의 연동 난이도
- 배포 용이성(단일 실행 파일, 자동 업데이트)
- 성능: GUI 프레임워크 오버헤드, 메모리 풋프린트
- 네이티브 기능 접근(파일 탐색기, 알림, OS 자원 모니터링)
- 커뮤니티/생태계 및 장기 유지보수성
- UI 생산성: 컴포넌트 라이브러리, 상태관리, 테스트 도구

## 5. 후보 기술 비교
| 구분 | 주요 구성/언어 | 강점 | 약점 | 적합도 |
| --- | --- | --- | --- | --- |
| Electron + React | TypeScript, Node.js, Chromium | 생태계 풍부, Electron Builder로 배포 용이 | 메모리 사용량 큼(200MB+), Node 버전과 Python gRPC 브릿지 관리 필요 | ★★★☆ |
| Tauri + React | TypeScript + Rust Core + WebView2 | 바이너리 20~40MB, Rust 레이어에서 Python 호출 안전, 보안 sandbox | Rust 학습 필요, 일부 OS 기능 플러그인 성숙도 제한 | ★★★★ |
| PySide6/Qt | Python + QML/QtQuick | Python 단일 언어, Qt Designer 활용 가능 | 패키지 용량 큼(>200MB), WebView 성능 아쉬움, 최신 UI/테마 구현 비용 | ★★☆ |
| Web SPA + FastAPI(로컬 서버) | Next.js/React + FastAPI | 웹 브라우저 기반으로 접근 쉬움, 서버/클라이언트 분리 명확 | 배포 2컴포넌트 관리, 오프라인 환경에서 포트 충돌 관리 필요 | ★★★ |

## 6. 권장안: React(TypeScript) + Tauri + FastAPI 임베디드
### 선택 사유
- Tauri의 가벼운 런타임과 Rust Command를 통해 Python 프로세스를 안전하게 스폰/모니터 가능
- 기존 CSA CLI 모듈을 FastAPI 마이크로서비스로 래핑하여 GUI와 동일한 인터페이스 제공
- React + TypeScript로 컴포넌트화/테스트 자동화 용이, 디자인 시스템 도입 쉬움
- 자동 업데이트, 코드사인, 권한 제어 등 배포 요구사항 충족

### 제안 아키텍처
```mermaid
graph LR
    User --> UI[React + Vite SPA (Tauri WebView)]
    UI -->|IPC| TauriCmd[Tauri Command (Rust)]
    TauriCmd --> PySvc[Embedded FastAPI Server]
    PySvc --> CSA[CSA Core Modules & CLI]
    CSA --> Neo4j[(Neo4j DB)]
    CSA --> Output[Reports / Diagrams / Logs]
    UI --> Storage[AppConfig / Workspace]
```

### 기술 스택 제안
- 프론트엔드: React 18 + Vite + TypeScript, Zustand/Recoil 상태 관리, Chakra UI 또는 Mantine 컴포넌트, TanStack Query로 비동기 상태 통합
- 크로스 플랫폼 쉘: Tauri 2.x, Rust 1.80+, Tauri Plugin Shell/Process로 CLI 실행, Tray/Notification 플러그인 사용
- 백엔드 브릿지: FastAPI + Uvicorn(embedded), Pydantic v2, CSA 모듈을 패키지로 import 후 BackgroundTasks로 분석 파이프라인 실행
- 공용 모듈: SQLite(Local cache) + Prisma/SQLModel, structlog 기반 로깅, 선택적 telemetry(비활성 기본)

### 단계별 접근
1. **Phase 0 (2주)**: Tauri 셋업, FastAPI 내장, Analyze 명령 실행/로그 스트림 POC
2. **Phase 1 (4주)**: 프로젝트 설정 마법사, 실행 히스토리, 결과 파일 뷰어
3. **Phase 2 (4주)**: Neo4j 상태 모니터, 시퀀스/CRUD 미리보기, 예약 실행
4. **Phase 3 (3주)**: AI Enrich 제어, 사용자 역할/프로필, 자동 업데이트

## 7. 리스크 및 대응
| 리스크 | 설명 | 대응 전략 |
| --- | --- | --- |
| Python 가상환경 관리 | GUI에서 CLI와 동일한 venv 보장 필요 | Tauri/Rust에서 `.venv/Scripts/python` 직접 호출, venv 경로 탐지 모듈화 |
| 장시간 분석 시 UI 응답성 | 수십 분 분석 동안 프론트가 멈출 수 있음 | FastAPI BackgroundTasks + WebSocket progress, cancel/retry API 설계 |
| Neo4j 인증 정보 보안 | GUI에 비밀번호 저장 필요 | OS 별 안전 저장소(Windows Credential Locker, macOS Keychain, SecretService) 래퍼 구현 |
| 업데이트 배포 | 기업망 환경에서 자동 업데이트 제한 | 오프라인 패치 패키지 + 내부 파일 공유 배포 모드 지원 |

## 8. 다음 액션
- UX 목업 및 컴포넌트 키트 합의
- FastAPI 래퍼 설계서/스펙 작성
- PoC 레포 구성(Tauri workspace + CSA 패키지) 및 CI 파이프라인 정의
